AWSTemplateFormatVersion: '2010-09-09'
Description: 'CarbonLens High-Performance AWS Setup - Optimized for Fast Gemini Processing'

Parameters:
  ProjectName:
    Type: String
    Default: 'carbonlens'
    Description: 'Name of the project for resource naming'
  
  Environment:
    Type: String
    Default: 'dev'
    AllowedValues: ['dev', 'staging', 'prod']
    Description: 'Environment name'
  
  GeminiApiKey:
    Type: String
    NoEcho: true
    Description: 'Gemini API Key for AI processing'

Resources:
  # VPC for high-performance networking
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-${Environment}-vpc'

  # Internet Gateway
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-${Environment}-igw'

  InternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref InternetGateway
      VpcId: !Ref VPC

  # Public Subnet for EC2 instances
  PublicSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [0, !GetAZs '']
      CidrBlock: 10.0.1.0/24
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-${Environment}-public-subnet'

  # Route Table
  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-${Environment}-public-routes'

  DefaultPublicRoute:
    Type: AWS::EC2::Route
    DependsOn: InternetGatewayAttachment
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PublicSubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicRouteTable
      SubnetId: !Ref PublicSubnet

  # Security Group for EC2
  EC2SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub '${ProjectName}-${Environment}-ec2-sg'
      GroupDescription: Security group for high-performance EC2 instances
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 3000
          ToPort: 3000
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0

  # IAM Role for EC2
  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ProjectName}-${Environment}-ec2-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonS3FullAccess
        - arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Policies:
        - PolicyName: CustomEC2Policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - elasticache:*
                  - sqs:*
                  - sns:*
                Resource: '*'

  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref EC2Role

  # High-Performance EC2 Instance for Gemini Processing
  GeminiProcessingInstance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: ami-0c02fb55956c7d316  # Amazon Linux 2023
      InstanceType: c6i.2xlarge  # High-performance compute optimized
      KeyName: !Sub '${ProjectName}-keypair'  # You'll need to create this
      SubnetId: !Ref PublicSubnet
      SecurityGroupIds:
        - !Ref EC2SecurityGroup
      IamInstanceProfile: !Ref EC2InstanceProfile
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          yum update -y
          yum install -y nodejs npm git htop redis docker
          
          # Install Node.js 18
          curl -fsSL https://rpm.nodesource.com/setup_18.x | bash -
          yum install -y nodejs
          
          # Start services
          systemctl start docker
          systemctl enable docker
          systemctl start redis
          systemctl enable redis
          
          # Create app directory
          mkdir -p /opt/carbonlens
          cd /opt/carbonlens
          
          # Clone your project (you'll need to update this with your repo)
          # git clone https://github.com/yourusername/carbonlens.git .
          
          # Create Gemini optimization service
          cat > gemini-service.js << 'EOF'
          const express = require('express');
          const redis = require('redis');
          const { GoogleGenerativeAI } = require('@google/generative-ai');
          
          const app = express();
          const port = 3000;
          
          // Redis client for caching
          const redisClient = redis.createClient({
            host: 'localhost',
            port: 6379
          });
          
          // Gemini AI client
          const genAI = new GoogleGenerativeAI('${GeminiApiKey}');
          const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });
          
          app.use(express.json({ limit: '50mb' }));
          
          // Connection pooling for Gemini requests
          const requestQueue = [];
          const processingQueue = [];
          let isProcessing = false;
          
          // Batch processing function
          async function processBatch() {
            if (isProcessing || requestQueue.length === 0) return;
            
            isProcessing = true;
            const batch = requestQueue.splice(0, 5); // Process 5 at a time
            
            const promises = batch.map(async (item) => {
              try {
                const cacheKey = `gemini:${item.hash}`;
                
                // Check cache first
                const cached = await redisClient.get(cacheKey);
                if (cached) {
                  item.resolve(JSON.parse(cached));
                  return;
                }
                
                // Make Gemini request
                const result = await model.generateContent(item.prompt);
                const response = result.response.text();
                
                // Cache for 1 hour
                await redisClient.setex(cacheKey, 3600, JSON.stringify(response));
                
                item.resolve(response);
              } catch (error) {
                item.reject(error);
              }
            });
            
            await Promise.all(promises);
            isProcessing = false;
            
            // Process next batch if available
            if (requestQueue.length > 0) {
              setTimeout(processBatch, 100);
            }
          }
          
          // Optimized Gemini endpoint
          app.post('/analyze-carbon', async (req, res) => {
            try {
              const { productData } = req.body;
              const prompt = buildAnalysisPrompt(productData);
              const hash = require('crypto').createHash('md5').update(prompt).digest('hex');
              
              const promise = new Promise((resolve, reject) => {
                requestQueue.push({ prompt, hash, resolve, reject });
                processBatch();
              });
              
              const result = await promise;
              res.json({ success: true, analysis: result });
              
            } catch (error) {
              res.status(500).json({ error: error.message });
            }
          });
          
          function buildAnalysisPrompt(productData) {
            return `Analyze the carbon footprint of this product and provide specific alternative product recommendations with carbon savings. Return ONLY valid JSON:

Product: ${productData.name || 'Unknown'} by ${productData.brand || 'Unknown'}
Category: ${productData.category || 'Unknown'}
Ingredients: ${productData.ingredients || 'Not specified'}

IMPORTANT: For recommendations, provide 3 MAINSTREAM and POPULAR alternative products that users will recognize. Use well-known brands available in major stores (Walmart, Target, grocery stores). Calculate actual carbon savings compared to this product.

Recommendation format requirements:
- Use proper capitalization (not ALL CAPS)
- Include "kg" in carbon savings
- Format: "Brand Name Product - saves X kg carbon per 1000 units"
- Choose products consumers actually know and can find easily

CRITICAL: Use REALISTIC VALUES based on actual product categories. DO NOT HALLUCINATE or use unrealistic numbers.

STRICT REALISTIC RANGES BY PRODUCT TYPE:
- BEVERAGES (soda, juice): carbonFootprint 0.1-0.5 kg CO₂, waterUsage 1-10 liters, waterInGallons 0.3-3 gallons (MAX 3 GALLONS)
- FOOD SPREADS (Nutella, peanut butter): carbonFootprint 1-5 kg CO₂, waterUsage 50-500 liters, waterInGallons 13-132 gallons
- SNACKS (chips, cookies): carbonFootprint 0.5-3 kg CO₂, waterUsage 10-100 liters, waterInGallons 3-26 gallons
- DAIRY PRODUCTS: carbonFootprint 1-8 kg CO₂, waterUsage 100-1000 liters, waterInGallons 26-264 gallons

MANDATORY CONSTRAINTS:
- For BEVERAGES: waterInGallons MUST be between 0.3-3 gallons (convert liters × 0.264)
- For BEVERAGES: treesAbsorbed MUST be between 0.005-0.025 trees
- For BEVERAGES: milesDriven MUST be between 0.25-1.25 miles
- NEVER exceed these ranges or the analysis will be rejected

For environmentalEquivalents, use EXACT CALCULATIONS:
- treesPer1000Units = treesAbsorbed × 1000 (simple multiplication)
- waterInGallons = waterUsage × 0.264172 (liters to gallons conversion)
- milesDriven = carbonFootprint × 2.5 (realistic conversion)
- treesAbsorbed = carbonFootprint × 0.05 (realistic tree absorption rate)

Return this exact JSON structure with REALISTIC estimates within the ranges above:
{
  "carbonFootprint": {
    "perUnit": 0.0,
    "per1000Units": 0.0,
    "breakdown": {
      "production": 0.0,
      "transportation": 0.0,
      "packaging": 0.0,
      "distribution": 0.0
    }
  },
  "waterUsage": {
    "perUnit": 0,
    "per1000Units": 0
  },
  "environmentalEquivalents": {
    "treesAbsorbed": 0,
    "treesPer1000Units": 0,
    "milesDriven": 0,
    "waterInGallons": 0,
    "plasticBottlesEquivalent": 0
  },
  "sustainabilityScore": 0,
  "recommendations": [
    "Brand Name Product - saves X kg carbon per 1000 units",
    "Brand Name Product - saves X kg carbon per 1000 units",
    "Brand Name Product - saves X kg carbon per 1000 units"
  ],
  "analysis": {
    "keyFindings": "Brief summary",
    "strengths": "Positive aspects",
    "concerns": "Environmental concerns"
  }
}`;
          }
          
          app.listen(port, () => {
            console.log(`Gemini service running on port ${port}`);
          });
          EOF
          
          # Install dependencies
          npm init -y
          npm install express redis @google/generative-ai
          
          # Start the service
          node gemini-service.js &
          
          # Install CloudWatch agent
          wget https://s3.amazonaws.com/amazoncloudwatch-agent/amazon_linux/amd64/latest/amazon-cloudwatch-agent.rpm
          rpm -U ./amazon-cloudwatch-agent.rpm
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-${Environment}-gemini-processor'

  # ElastiCache Redis for caching
  ElastiCacheSubnetGroup:
    Type: AWS::ElastiCache::SubnetGroup
    Properties:
      Description: Subnet group for ElastiCache
      SubnetIds:
        - !Ref PublicSubnet

  ElastiCacheSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for ElastiCache
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 6379
          ToPort: 6379
          SourceSecurityGroupId: !Ref EC2SecurityGroup

  ElastiCacheCluster:
    Type: AWS::ElastiCache::CacheCluster
    Properties:
      CacheNodeType: cache.r6g.large
      Engine: redis
      NumCacheNodes: 1
      VpcSecurityGroupIds:
        - !Ref ElastiCacheSecurityGroup
      CacheSubnetGroupName: !Ref ElastiCacheSubnetGroup
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-${Environment}-redis'

  # SQS Queue for async processing
  ProcessingQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub '${ProjectName}-${Environment}-processing-queue'
      VisibilityTimeoutSeconds: 300
      MessageRetentionPeriod: 1209600  # 14 days
      ReceiveMessageWaitTimeSeconds: 20  # Long polling

  # CloudFront Distribution for faster image delivery
  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Origins:
          - Id: S3Origin
            DomainName: !Sub '${ProductImagesBucket}.s3.amazonaws.com'
            S3OriginConfig:
              OriginAccessIdentity: ''
        Enabled: true
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
          CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad  # CachingOptimized
          OriginRequestPolicyId: 88a5eaf4-2fd4-4709-b370-b4c650ea3fcf  # CORS-S3Origin
        PriceClass: PriceClass_All
        ViewerCertificate:
          CloudFrontDefaultCertificate: true

  # Enhanced Lambda Functions with more memory and provisioned concurrency
  EnhancedProductDetectionFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-${Environment}-enhanced-product-detection'
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 60
      MemorySize: 3008  # Maximum memory for better performance
      Environment:
        Variables:
          GEMINI_SERVICE_URL: !Sub 'http://${GeminiProcessingInstance.PublicIp}:3000'
          REDIS_ENDPOINT: !GetAtt ElastiCacheCluster.RedisEndpoint.Address
          SQS_QUEUE_URL: !Ref ProcessingQueue
      ReservedConcurrencyLimit: 100
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const https = require('https');
          
          exports.handler = async (event) => {
            // Enhanced product detection with caching and async processing
            console.log('Enhanced product detection started');
            
            try {
              const { imageData, userId } = JSON.parse(event.body);
              
              // Use the high-performance Gemini service
              const geminiResponse = await callGeminiService(imageData);
              
              return {
                statusCode: 200,
                headers: {
                  'Access-Control-Allow-Origin': '*',
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  success: true,
                  analysis: geminiResponse,
                  processingTime: Date.now() - startTime
                })
              };
              
            } catch (error) {
              return {
                statusCode: 500,
                body: JSON.stringify({ error: error.message })
              };
            }
          };
          
          async function callGeminiService(imageData) {
            // Call the optimized Gemini service on EC2
            const postData = JSON.stringify({ imageData });
            
            return new Promise((resolve, reject) => {
              const req = https.request({
                hostname: process.env.GEMINI_SERVICE_URL.replace('http://', '').split(':')[0],
                port: 3000,
                path: '/analyze-carbon',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Content-Length': Buffer.byteLength(postData)
                }
              }, (res) => {
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => resolve(JSON.parse(data)));
              });
              
              req.on('error', reject);
              req.write(postData);
              req.end();
            });
          }

  # Provisioned Concurrency for Lambda
  LambdaProvisionedConcurrency:
    Type: AWS::Lambda::ProvisionedConcurrencyConfig
    Properties:
      FunctionName: !Ref EnhancedProductDetectionFunction
      ProvisionedConcurrencyLevel: 10
      Qualifier: !GetAtt EnhancedProductDetectionFunction.Version

  # Application Load Balancer for high availability
  ApplicationLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub '${ProjectName}-${Environment}-alb'
      Scheme: internet-facing
      Type: application
      Subnets:
        - !Ref PublicSubnet
      SecurityGroups:
        - !Ref EC2SecurityGroup

  # Auto Scaling Group for EC2 instances
  LaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateName: !Sub '${ProjectName}-${Environment}-launch-template'
      LaunchTemplateData:
        ImageId: ami-0c02fb55956c7d316
        InstanceType: c6i.2xlarge
        SecurityGroupIds:
          - !Ref EC2SecurityGroup
        IamInstanceProfile:
          Arn: !GetAtt EC2InstanceProfile.Arn
        UserData:
          Fn::Base64: !Sub |
            #!/bin/bash
            # Same user data as above but for auto scaling

  AutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      AutoScalingGroupName: !Sub '${ProjectName}-${Environment}-asg'
      LaunchTemplate:
        LaunchTemplateId: !Ref LaunchTemplate
        Version: !GetAtt LaunchTemplate.LatestVersionNumber
      MinSize: 1
      MaxSize: 5
      DesiredCapacity: 2
      VPCZoneIdentifier:
        - !Ref PublicSubnet
      TargetGroupARNs:
        - !Ref TargetGroup

  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub '${ProjectName}-${Environment}-tg'
      Port: 3000
      Protocol: HTTP
      VpcId: !Ref VPC
      HealthCheckPath: /health
      HealthCheckProtocol: HTTP

  # CloudWatch Dashboard for monitoring
  PerformanceDashboard:
    Type: AWS::CloudWatch::Dashboard
    Properties:
      DashboardName: !Sub '${ProjectName}-${Environment}-performance'
      DashboardBody: !Sub |
        {
          "widgets": [
            {
              "type": "metric",
              "properties": {
                "metrics": [
                  ["AWS/Lambda", "Duration", "FunctionName", "${EnhancedProductDetectionFunction}"],
                  ["AWS/Lambda", "Invocations", "FunctionName", "${EnhancedProductDetectionFunction}"],
                  ["AWS/Lambda", "Errors", "FunctionName", "${EnhancedProductDetectionFunction}"]
                ],
                "period": 300,
                "stat": "Average",
                "region": "${AWS::Region}",
                "title": "Lambda Performance"
              }
            },
            {
              "type": "metric",
              "properties": {
                "metrics": [
                  ["AWS/EC2", "CPUUtilization", "InstanceId", "${GeminiProcessingInstance}"],
                  ["AWS/EC2", "NetworkIn", "InstanceId", "${GeminiProcessingInstance}"],
                  ["AWS/EC2", "NetworkOut", "InstanceId", "${GeminiProcessingInstance}"]
                ],
                "period": 300,
                "stat": "Average",
                "region": "${AWS::Region}",
                "title": "EC2 Performance"
              }
            }
          ]
        }

Outputs:
  GeminiServiceUrl:
    Description: 'High-Performance Gemini Service URL'
    Value: !Sub 'http://${GeminiProcessingInstance.PublicIp}:3000'
    Export:
      Name: !Sub '${ProjectName}-${Environment}-gemini-service-url'

  RedisEndpoint:
    Description: 'Redis Cache Endpoint'
    Value: !GetAtt ElastiCacheCluster.RedisEndpoint.Address
    Export:
      Name: !Sub '${ProjectName}-${Environment}-redis-endpoint'

  LoadBalancerUrl:
    Description: 'Application Load Balancer URL'
    Value: !GetAtt ApplicationLoadBalancer.DNSName
    Export:
      Name: !Sub '${ProjectName}-${Environment}-alb-url'

  CloudFrontUrl:
    Description: 'CloudFront Distribution URL'
    Value: !GetAtt CloudFrontDistribution.DomainName
    Export:
      Name: !Sub '${ProjectName}-${Environment}-cloudfront-url'
